using System.Net;
using System.Net.Sockets;
using System.Text;

namespace ServerTCP
{
    // Протокол TCP
    // - переваги - 
    //    Незалежність від мережної технології.TCP/IP не залежить від обладнання, так як він визначає елемент передачі – дейтаграму та описує спосіб її руху мережею;
    //    Загальна зв’язаність.Стек дозволяє будь-якій парі комп’ютерів, що його підтримують, взаємодіяти один з одним.Кожному комп’ютеру надається логічна адреса, а кожна дейтаграма, що передається, містить логічні адреси відправника та одержувача;
    //    Підтвердження.Протоколи стеку TCP/IP забезпечують підтвердження правильності проходження при обміні між відправником та одержувачем;
    //    Стандартні прикладні програми.Протокол TCP/IP містить засоби підтримки основних прикладних програм, таких як, електронна пошта, передача файлів, віддалений доступ і т.і.    // - TCP - складний протокол та вимагає значних витрат русурсів системи, що пояснюється механізмами встановлення з'єднання, аде при цьому він бере на себе турботу про 
    //    гарантовану доставку пакетів, позбавляючи програміста необхідності включати цю функціональність у код додатків. 
    // - TCP повторно запитує дані в разі втрати даних і виключає дублювання при отриманні двох копій одного і того ж пакета.
    // На відміну від протоколу UDP, він гарантує, що додаток отримує дані в точно такій же послідовності, в якій воно було відправлено,
    // і без втрат.  Реалізація TCP зазвичай вбудована в ядро сучасної операційної системи

    // - недоліки - 
    //    Використання значних ресурсів (важкий протокол)
    //    TCP вимагає чіткої специфікації максимального розміру сегмента (MSS), якщо віртуальне з'єднання здійснюється через сегмент мережі, де максимальний розмір блоку (MTU) менше, ніж стандартний Ethernet MTU (1500 байт).
    //    У тунельних протоколах, таких як GRE, IPIP, максимальний розмір блоку тунелю менше стандартного розміру, тому максимальний сегмент TCP має довжину пакета більше, ніж MTU.Оскільки фрагментація заборонена в переважній більшості випадків, такі пакети викидаються.
    //    Застосовуваний алгоритм перевірки контрольних сум при передачі пакетів вважається слабким та може призвести до помилок


    public partial class Form1 : Form
    {

        Thread thread;

        public Form1()
        {
            InitializeComponent();
        }

        private void btnStartTCPServer_Click(object sender, EventArgs e)
        {
            // Створення нового потока та винесення підключення у цей потік
            // Перевірка наявності створеного потока (якщо потока немає - створюється новий)
            if(thread != null)
            {
                return;
            }

            // Створення нового фонового потока та запуск у ньому відповідної логіки (у методі ServerFunc)
            thread = new Thread(ServerFunc);
            thread.IsBackground = true;
            thread.Start();

            Text = "Server TCP was started !";
        }

        private void ServerFunc()
        {
            // Створення пасивного сокета через об'єкт TcpListener,
            // який і створить пасивний сокет та контролюватиме підключення клієнтів
            // - приймає 
            // IP-адрусу сервера
            // приймаючий порт сервера
            TcpListener listener = new TcpListener(IPAddress.Parse("192.168.56.1"), 11000);

            try
            {
                // Запуск ліснера та контроль за кількістю одночасно підключених клієнтів
                listener.Start(10);

                // Цикл прослуховування підключення клієнтів
                do 
                {
                    // Перевірка - якщо є клієнти, які чекають підключення (метод Pending()) -
                    // для їх підключення створюється АКТИВНИЙ сокет клієнта
                    if (listener.Pending())
                    {
                        // Створення сокета для підключення Активного сокета клієнта
                        // - передається підключення через об'єкт listener та
                        // отримується посилання на підключення клієнта (AcceptTcpClient())
                        // на даному етапі з клієнтом можна взаємодіяти
                        TcpClient client = listener.AcceptTcpClient();

                        // "Стандартна" робота з клієнтом
                        // створення буфера для отримання/відправки даних
                        byte[] buffer = new byte[1024];

                        // -------------------------------- Отримання даних від клієнта ------------------------------
                        // отримання даних через виклик у клієнта методу GetStream() та поміщення результату у змінну типу NetworkStream (МережевийПотік)
                        NetworkStream ns = client.GetStream();

                        // Зчитування даних з мережевого потоку - кількість прочитаних байт зберігається у змінній типу int
                        int len = ns.Read(buffer, 0, buffer.Length);

                        // Виведення до візуального компонента статистики підключення та отриманого повідомлення
                        StringBuilder sb = new StringBuilder();
                        //sb.Append($"{len} was recived from {client.Client.RemoteEndPoint} {Environment.NewLine}");
                        sb.AppendLine($"{len} was recived from {client.Client.RemoteEndPoint}"); // анатолічно попередньому рядку
                        sb.AppendLine(Encoding.Default.GetString(buffer, 0, len));

                        // Передача даних, отриманих від клієнта з фонового потоку до візуального компонента у головному потоці
                        // використовується делегат Action<>
                        // (войд, типізується рідком, приймає метод (самописний) в якому описана логіка передачі інф до візуального компонента)
                        tbServerTCPStatistic.BeginInvoke(new Action<string>(AddText), sb.ToString());
                        // -------------------------------------------------------------------------------------------


                        // -------------------------------- ВІДПРАВКА відповіді клієнту ------------------------------
                        ns.Write(Encoding.Default.GetBytes($"Test text {Encoding.Default.GetString(buffer, 0, len)}"));
                        // -------------------------------------------------------------------------------------------


                        // вимкнення / закриття сокета
                        client.Client.Shutdown(SocketShutdown.Receive);
                        client.Close();
                    }

                } while (true);
            }
            catch (SystemException ex)
            {
                MessageBox.Show(ex.Message);
            }
            finally
            {
                // Закриття з'єднання - через звернення до пасивного сокета listener
                listener.Stop();
            }
        }

        private void AddText(string str)
        {
            StringBuilder sb = new StringBuilder(tbServerTCPStatistic.Text);
            sb.Append(str);
            tbServerTCPStatistic.Text = sb.ToString();
        }
    }
}